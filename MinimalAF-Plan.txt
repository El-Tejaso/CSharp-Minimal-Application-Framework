------------

TODO:
	-> Give Elements their own coordinate systems, and drawing capabilities. Elements should be able to work anywhere in the subtree.
		- If they are all grounding themselves using Width and Height, I should just be able to give them a different width and height (Happens automatically so I dont have to do anything really), and make the offset based on the screen position. Then use a GLScissor to constrain the drawing. Can still work with 3D cause of viewports.
		
		- It kinda works, I just need to get the stencilling to work.
		- make input work no matter where the rect is
			- drawing needs to be relative to a rect
				- We shouldnt need to do any calls to CTX. we should just be able to do Rect() from inside the class. may also be helpful to be able to do VW() and VH()
					- make all drawing classes internal static
						- remove references to them in ctx
							- Don't do this. We made those classes, so that we can reuse them in a procedural mesh generation context.
					- copy-paste all the calls into a seperate element partial class. it is mainly for syntactic sugar.
						- view, model, projection matriceis need to be put into an array so that the PushMatrix code can be cleaned up
					- fix tests
					- change all getters and setters to be like Jquery where its like method() is a getter and method(value) is a setter
						- terrible idea. Only do this for methods that invoke drawing related sideeffects or set things elsewhere rather than just raw getters and setters, we should still use Get and Set for state retrieval
					
			- input needs to be relative to a rect, and should be invokeable in the same way as those other draw calls cause it looks nice
				- mouse input mainly. use the same syntactic sugar as the drawing API and add input methods directly to the class in a partial extension
					- Wrap the mouse X, Y to make it relative
					- Remove all the redundant methods in the mouse, then copy those over too
						- filter them as we transfer them to ElementInputExtensions
					- do it all for keyboard input as well for consistency.
					- Create a visual test to test the mouse input, dragging in particular
						- make it so you need to drag the polyline
			
			- switch brackets back to method() 
				- add .editorconfig

		-> Fix the UI Lifecycle functions
			-> remove OnStart, replace it with OnMount, OnDismount like REACT, also makes more sense when logically reasoning about object lifetimes.
				- And remove the need to call base. anything
				-> Remove IWindowResources. Why is this even a thing
					-> looks like it has a reason to be there, but I dont buy it. I think any element should be able to have state. Make an interface IResource, and GetResource<IResource> functions that go up the tree and check if a node has a resource. 
						- Don't. MAke a UIState element that we can get to do these things. This pattern may lead to long chains of 1 like Window=>resource->resource->resource->resource->resource appearing everywhere.
						For this reason, we should make a State element that can store arbitrary state. And only if things need to have to keep state up to date based on lifecycle methods do we need to make them a Element of their own.
						- unit test?
							- not yet, we can use this feature when we update the unit test for text inptus though
				
			-> fix UI API to calculate layout during OnResize and not in an initialization phase. This will allow us to have more flexibility with layout in future
				-> Make all the 'in-rows' whatever methods not be initialziation methods but resizing methods
					-> Fix up the UI tests. I can't think of any other way to do this. We can work backwards, by typing in our ideal API there and then makeing the necessary refactorings as we did before
						- The UI system shouldn't be a part of MinimalAF. It should ship seperately.
							- maybe it should come with it, since I want to ship it with everything I need to make anything ever.
							- I will figure out some way to seperate the styling from the logic, and we can ship the logic and none of the styling
							- Remove unity inspired RectTransform. It may actually be hindering us rather than helping us. 
								- replace it with layout methods. Right now we are doing this with anchors, but we don't need to. 
									- renamed Rect2D to Rect. Rects can only be 2D lol so its redundant you see (nerd emoji)
				-> Start going through the tests one by one and fixing them
					-> the layout logic is still wack. if elemetns are driving their children's layout, it doesnt matter because the recursion will just undo those changes. Also, if the window moves alittle, should every single object really update it's layout ?
						- also, every rectangle is going to be relative to the previous rectangle. 
						
New layouting algorithm:
Imagine: rectangle with several textboxes whose width match the rectangle but they are arranged vertically on after the other. This algorithm should work for scaling of this rectangle:

	1) scale rectangle, trigger update in all children
	2) expand all children to fill all directions
	3) expand the text within to fill all directions, recalculate it
	4) make the text to have the same dimensions as the strign width and height
	5) Arrange chldren
	
it looks kinad recursive:
fill parent
	fill-parent
		recalc text
	fit-to-text-size
arrange-children

So then in OnLayout, parents calculate child sizes, and then in AfterLayout, each item is arranging it's child objects and then fixing up their sizes for the parent to arrange them.
						
				-> get code compiling, and fix issues
						
				-* Make a unit test with two columns and cards, and we can drag+drop the cards amongst the columns and between them
									
		-* Eliminate the need for all 'Screen space to world space' code for 2D rectangles in the UI tree (However if there is a 3D scene within one of those, that will need to implement something like that but that is none of our concern)
			-* Allow elements to define an internal scale. Perhaps seperate ones for X and Y, or both at the same time. For instance, if we wanted the width of our UI to be 700 units, then we can say that WIDTH * unit = 700 => the unit is 700/WIDTH units per pixel. Something like SetUnitsPerPixel(700 / VW(1));
				-* needs to be done in the resize function
			And this can call SetUnitsPerPixelWidth(x) and ...Height(x);
			And this can scale the projection matrix
				-* Then we need UnitsWidth and UnitsHeight, since VW and VH won't cut it anymore
		-* Recreate all UI If needed
		-* fix all UI tests


---- day 3

	-* 3D immediate and non-immediate support
	
---- day 4
	-* implement Disposable for Audiosource and 	possibly other classes
		since they are now pooled
		
	-* Test harness that collates all unit tests
		-* Create An Attribute is used to mark tests
		-* Create a subprogram that can aggregate and show all unit tests
		
---- day 7
		
	-* clipping needs to be toggleable
		-* remove setRect
		
	- Framebuffer optimization
		- texture buffer resizing [Texture.cs ln 68]
			- currently created with new() each time

	
		
	- Add unit tests for renderbuffer
		- find rare memory corruption that may now be fixed
		
	- Strip down CTX class. Alot of useless stuff there imo
					
	-* Add dynamic compilation
		-* find that ms doc page about c# dynamic compilation
			
	-* Add HSV to Color4

Done so far:
	- Seperate app config and window management from Rendering and updating code. 
		- Move all drawing code into UIElement
		- Split UIElement into multiple files, since it will be big
	- Enough with this wrapper pattern in CTX and Input.
		- rather than CTX.DrawRectangle, do 
			CTX.Rectangle.Draw();
			So I have far less code to maintain
			
	- Move datatypes to where they are needed. Make them Core if they are cross-cutting
		- Removed useless/bad datastructures
	
	- Figure out some way to use System.Drawing.Color because it has a lot more builtin colors
		- added all named colors from wikipedia